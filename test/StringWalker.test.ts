import * as util from "../src"	

describe('StringWalker', () => {	

  const StringWalker = util.StringWalker	

  test('constructor', () => {	
    const walker = new StringWalker("inðŸ˜€put")	
    expect(walker.c).toBe("i")	
  })	

  test('empty string', () => {	
    const walker = new StringWalker("")	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
    walker.prev()	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
    walker.next()	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
    walker.seek(-1)	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
    walker.seek(1)	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
    walker.seek(0, util.SeekOrigin.Start)	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
    walker.seek(0, util.SeekOrigin.End)	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
    walker.next()	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
    walker.prev()	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
  })	

  test('eof', () => {	
    const walker = new StringWalker("inpðŸ˜€ut")	
    expect(walker.eof).toBe(false)	
    walker.seek(10)	
    expect(walker.eof).toBe(true)	
    const emptyWalker = new StringWalker("")	
    expect(emptyWalker.eof).toBe(true)	
  })	

  test('codePoint', () => {	
    const walker = new StringWalker("inpðŸ˜€ut")	
    expect(walker.codePoint).toBe(0x69)	
    expect(walker.codePoint).toBe(0x69)	
    walker.seek(10)	
    expect(walker.codePoint).toBe(-1)	
  })	

  test('c', () => {	
    const walker = new StringWalker("inpðŸ˜€ut")	
    expect(walker.c).toBe("i")	
    expect(walker.c).toBe("i")	
    walker.seek(10)	
    expect(walker.c).toBe("")	
  })	

  test('peek()', () => {	
    const walker = new StringWalker("inpðŸ˜€ut\uD83Dx")	
    expect(walker.peek()).toBe("inpðŸ˜€ut\uD83Dx")	
    expect(walker.peek(4)).toBe("inpðŸ˜€")	
    walker.seek(4)	
    expect(walker.peek()).toBe("ut\uD83Dx")	
    expect(walker.peek(2)).toBe("ut")	
    expect(walker.peek(200)).toBe("ut\uD83Dx")	
    walker.seek(10)	
    expect(walker.peek()).toBe("")	
  })	

  test('peekChar()', () => {	
    const walker = new StringWalker("input  x")	
    expect(walker.peekChar()).toBe("input  x")	
    expect(walker.peekChar(5)).toBe("input")	
    walker.seekChar(5)	
    expect(walker.peekChar()).toBe("  x")	
    expect(walker.peekChar(2)).toBe("  ")	
    expect(walker.peekChar(200)).toBe("  x")	
    walker.seek(10)	
    expect(walker.peekChar()).toBe("")	
  })	

  test('startsWith()', () => {	
    const walker = new StringWalker("inpðŸ˜€ut")	
    walker.next()	
    expect(walker.startsWith("np")).toBe(true)	
    expect(walker.startsWith("NPðŸ˜€")).toBe(false)	
    expect(walker.startsWith("NPðŸ˜€", true)).toBe(true)	
    expect(walker.startsWith("not possible")).toBe(false)	
    expect(walker.startsWith("no", true)).toBe(false)	
    expect(walker.startsWith("x")).toBe(false)	
    walker.seek(10)	
    expect(walker.startsWith("in")).toBe(false)	
  })	

  test('next()', () => {	
    const walker = new StringWalker("inpðŸ˜€ut\uD83Dx")	
    expect(walker.c).toBe("i")	
    walker.next()	
    walker.next()	
    expect(walker.c).toBe("p")	
    walker.next()	
    expect(walker.c).toBe("ðŸ˜€")	
    walker.next()	
    expect(walker.c).toBe("u")	
    walker.next()	
    expect(walker.c).toBe("t")	
    walker.next()	
    expect(walker.c).toBe("\uD83D")	
    walker.next()	
    expect(walker.c).toBe("x")	
    walker.next()	
    expect(walker.eof).toBe(true)	
    expect(walker.next()).toBe(false)	
  })	

  test('nextChar()', () => {	
    const walker = new StringWalker("input  x")	
    expect(walker.c).toBe("i")	
    walker.nextChar()	
    walker.nextChar()	
    expect(walker.c).toBe("p")	
    walker.nextChar()	
    expect(walker.c).toBe("u")	
    walker.seekChar(10)	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
    expect(walker.nextChar()).toBe(false)	
  })	

  test('prev()', () => {	
    const walker = new StringWalker("inpðŸ˜€ut\uDE00x")	
    walker.seek(10)	
    expect(walker.c).toBe("")	
    walker.prev()	
    expect(walker.c).toBe("x")	
    walker.prev()	
    expect(walker.c).toBe("\uDE00")	
    walker.prev()	
    expect(walker.c).toBe("t")	
    walker.prev()	
    expect(walker.c).toBe("u")	
    walker.prev()	
    expect(walker.c).toBe("ðŸ˜€")	
    walker.prev()	
    walker.prev()	
    expect(walker.c).toBe("n")	
    walker.prev()	
    expect(walker.c).toBe("i")	
    walker.prev()	
    expect(walker.c).toBe("i")	
    expect(walker.eof).toBe(false)	
    expect(walker.prev()).toBe(false)	
  })	

  test('prevChar()', () => {	
    const walker = new StringWalker("input  x")	
    walker.seekChar(10)	
    expect(walker.c).toBe("")	
    walker.prevChar()	
    expect(walker.c).toBe("x")	
    walker.prevChar()	
    walker.prevChar()	
    walker.prevChar()	
    expect(walker.c).toBe("t")	
    walker.seekChar(-10)	
    expect(walker.c).toBe("i")	
    expect(walker.eof).toBe(false)	
    expect(walker.prevChar()).toBe(false)	
  })	

  test('seek()', () => {	
    const walker = new StringWalker("inpðŸ˜€ut\uDE00x")	
    walker.seek(10)	
    expect(walker.c).toBe("")	
    walker.seek(-10)	
    expect(walker.c).toBe("i")	
    walker.seek(0, util.SeekOrigin.Start)	
    expect(walker.c).toBe("i")	
    walker.seek(0, util.SeekOrigin.End)	
    expect(walker.c).toBe("")	
    walker.seek(-10)	
    expect(walker.c).toBe("i")	
    walker.seek(3)	
    expect(walker.c).toBe("ðŸ˜€")	
    walker.seek(1)	
    expect(walker.peek(2)).toBe("ut")	
    walker.seek(2)	
    expect(walker.c).toBe("\uDE00")	
    walker.seek(1)	
    expect(walker.c).toBe("x")	
    walker.seek(1)	
    expect(walker.eof).toBe(true)	
  })	

  test('seek() with surrogates', () => {	
    const walker = new StringWalker("ðŸ˜€xðŸ˜€")	
    walker.seek(10)	
    expect(walker.c).toBe("")	
    walker.seek(-10)	
    expect(walker.c).toBe("ðŸ˜€")	
    walker.seek(0, util.SeekOrigin.Start)	
    expect(walker.c).toBe("ðŸ˜€")	
    walker.seek(0, util.SeekOrigin.End)	
    expect(walker.c).toBe("")	
    walker.seek(-10)	
    expect(walker.c).toBe("ðŸ˜€")	
    walker.seek(2)	
    expect(walker.c).toBe("ðŸ˜€")	
    walker.seek(1)	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
  })	

  test('seek() with isolated surrogates', () => {	
    const walker = new StringWalker("\uDE00x\uDE00")	
    walker.seek(10)	
    expect(walker.c).toBe("")	
    walker.seek(-10)	
    expect(walker.c).toBe("\uDE00")	
    walker.seek(0, util.SeekOrigin.Start)	
    expect(walker.c).toBe("\uDE00")	
    walker.seek(0, util.SeekOrigin.End)	
    expect(walker.c).toBe("")	
    walker.seek(-10)	
    expect(walker.c).toBe("\uDE00")	
    walker.seek(3)	
    expect(walker.c).toBe("")	
    expect(walker.eof).toBe(true)	
  })	

  test('seekChar()', () => {	
    const walker = new StringWalker("input  x")	
    walker.seekChar(10)	
    expect(walker.c).toBe("")	
    walker.seekChar(-10)	
    expect(walker.c).toBe("i")	
    walker.seekChar(0, util.SeekOrigin.Start)	
    expect(walker.c).toBe("i")	
    walker.seekChar(0, util.SeekOrigin.End)	
    expect(walker.c).toBe("")	
    walker.seekChar(-10)	
    expect(walker.c).toBe("i")	
    walker.seekChar(3)	
    expect(walker.c).toBe("u")	
    walker.seekChar(1)	
    expect(walker.peekChar(2)).toBe("t ")	
    walker.seekChar(10)	
    expect(walker.eof).toBe(true)	
  })	

  test('take()', () => {	
    const walker = new StringWalker("input   x")	
    expect(walker.take(0)).toBe("")	
    expect(walker.take(5)).toBe("input")	
    expect(walker.c).toBe(" ")	
    expect(walker.take(c => c === "x")).toBe("")	
    expect(walker.take(c => c === " ")).toBe("   ")	
    expect(walker.c).toBe("x")	
    walker.take(1)	
    expect(walker.eof).toBe(true)	
  })	

  test('takeChar()', () => {	
    const walker = new StringWalker("input   x")	
    expect(walker.takeChar(0)).toBe("")	
    expect(walker.takeChar(5)).toBe("input")	
    expect(walker.c).toBe(" ")	
    expect(walker.takeChar(c => c === "x")).toBe("")	
    expect(walker.takeChar(c => c === " ")).toBe("   ")	
    expect(walker.c).toBe("x")	
    walker.takeChar(1)	
    expect(walker.eof).toBe(true)	
  })	

  test('skip()', () => {	
    const walker = new StringWalker("input   x")	
    expect(walker.c).toBe("i")	
    walker.skip(0)	
    expect(walker.c).toBe("i")	
    walker.skip(5)	
    expect(walker.c).toBe(" ")	
    walker.skip(c => c === "x")	
    expect(walker.c).toBe(" ")	
    walker.skip(c => c === " ")	
    expect(walker.c).toBe("x")	
    walker.skip(5)	
    expect(walker.eof).toBe(true)	
  })	

  test('skipChar()', () => {	
    const walker = new StringWalker("input   x")	
    expect(walker.c).toBe("i")	
    walker.skipChar(0)	
    expect(walker.c).toBe("i")	
    walker.skipChar(5)	
    expect(walker.c).toBe(" ")	
    walker.skipChar(c => c === "x")	
    expect(walker.c).toBe(" ")	
    walker.skipChar(c => c === " ")	
    expect(walker.c).toBe("x")	
    walker.skipChar(5)	
    expect(walker.eof).toBe(true)	
  })	

})
