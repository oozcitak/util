import * as util from "../src"

describe('StringWalker', () => {

  const StringWalker = util.StringWalker
  
  test('constructor', () => {
    const walker = new StringWalker("inðŸ˜€put")
    expect(walker.c).toBe("i")
  })

  test('empty string', () => {
    const walker = new StringWalker("")
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
    walker.prev()
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
    walker.next()
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
    walker.seek(-1)
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
    walker.seek(1)
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
    walker.seek(0, util.SeekOrigin.Start)
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
    walker.seek(0, util.SeekOrigin.End)
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
    walker.next()
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
    walker.prev()
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
  })

  test('eof', () => {
    const walker = new StringWalker("inpðŸ˜€ut")
    expect(walker.eof).toBe(false)
    walker.seek(10)
    expect(walker.eof).toBe(true)
    const emptyWalker = new StringWalker("")
    expect(emptyWalker.eof).toBe(true)
  })

  test('codePoint', () => {
    const walker = new StringWalker("inpðŸ˜€ut")
    expect(walker.codePoint).toBe(0x69)
    expect(walker.codePoint).toBe(0x69)
    walker.seek(10)
    expect(walker.codePoint).toBe(-1)
  })

  test('c', () => {
    const walker = new StringWalker("inpðŸ˜€ut")
    expect(walker.c).toBe("i")
    expect(walker.c).toBe("i")
    walker.seek(10)
    expect(walker.c).toBe("")
  })

  test('peek()', () => {
    const walker = new StringWalker("inpðŸ˜€ut\uD83Dx")
    expect(walker.peek()).toBe("inpðŸ˜€ut\uD83Dx")
    expect(walker.peek(4)).toBe("inpðŸ˜€")
    walker.seek(4)
    expect(walker.peek()).toBe("ut\uD83Dx")
    expect(walker.peek(2)).toBe("ut")
    expect(walker.peek(200)).toBe("ut\uD83Dx")
    walker.seek(10)
    expect(walker.peek()).toBe("")
  })

  test('startsWith()', () => {
    const walker = new StringWalker("inpðŸ˜€ut")
    walker.next()
    expect(walker.startsWith("np")).toBe(true)
    expect(walker.startsWith("NPðŸ˜€")).toBe(false)
    expect(walker.startsWith("NPðŸ˜€", true)).toBe(true)
    expect(walker.startsWith("not possible")).toBe(false)
    expect(walker.startsWith("no", true)).toBe(false)
    expect(walker.startsWith("x")).toBe(false)
    walker.seek(10)
    expect(walker.startsWith("in")).toBe(false)
  })

  test('next()', () => {
    const walker = new StringWalker("inpðŸ˜€ut\uD83Dx")
    expect(walker.c).toBe("i")
    walker.next()
    walker.next()
    expect(walker.c).toBe("p")
    walker.next()
    expect(walker.c).toBe("ðŸ˜€")
    walker.next()
    expect(walker.c).toBe("u")
    walker.next()
    expect(walker.c).toBe("t")
    walker.next()
    expect(walker.c).toBe("\uD83D")
    walker.next()
    expect(walker.c).toBe("x")
    walker.next()
    expect(walker.eof).toBe(true)
    expect(walker.next()).toBe(false)
  })

  test('prev()', () => {
    const walker = new StringWalker("inpðŸ˜€ut\uDE00x")
    walker.seek(10)
    expect(walker.c).toBe("")
    walker.prev()
    expect(walker.c).toBe("x")
    walker.prev()
    expect(walker.c).toBe("\uDE00")
    walker.prev()
    expect(walker.c).toBe("t")
    walker.prev()
    expect(walker.c).toBe("u")
    walker.prev()
    expect(walker.c).toBe("ðŸ˜€")
    walker.prev()
    walker.prev()
    expect(walker.c).toBe("n")
    walker.prev()
    expect(walker.c).toBe("i")
    walker.prev()
    expect(walker.c).toBe("i")
    expect(walker.eof).toBe(false)
  })
 
  test('seek()', () => {
    const walker = new StringWalker("inpðŸ˜€ut\uDE00x")
    walker.seek(10)
    expect(walker.c).toBe("")
    walker.seek(-10)
    expect(walker.c).toBe("i")
    walker.seek(0, util.SeekOrigin.Start)
    expect(walker.c).toBe("i")
    walker.seek(0, util.SeekOrigin.End)
    expect(walker.c).toBe("")
    walker.seek(-10)
    expect(walker.c).toBe("i")
    walker.seek(3)
    expect(walker.c).toBe("ðŸ˜€")
    walker.seek(1)
    expect(walker.peek(2)).toBe("ut")
    walker.seek(2)
    expect(walker.c).toBe("\uDE00")
    walker.seek(1)
    expect(walker.c).toBe("x")
    walker.seek(1)
    expect(walker.eof).toBe(true)
  })

  test('seek() with surrogates', () => {
    const walker = new StringWalker("ðŸ˜€xðŸ˜€")
    walker.seek(10)
    expect(walker.c).toBe("")
    walker.seek(-10)
    expect(walker.c).toBe("ðŸ˜€")
    walker.seek(0, util.SeekOrigin.Start)
    expect(walker.c).toBe("ðŸ˜€")
    walker.seek(0, util.SeekOrigin.End)
    expect(walker.c).toBe("")
    walker.seek(-10)
    expect(walker.c).toBe("ðŸ˜€")
    walker.seek(2)
    expect(walker.c).toBe("ðŸ˜€")
    walker.seek(1)
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
  })

  test('seek() with isolated surrogates', () => {
    const walker = new StringWalker("\uDE00x\uDE00")
    walker.seek(10)
    expect(walker.c).toBe("")
    walker.seek(-10)
    expect(walker.c).toBe("\uDE00")
    walker.seek(0, util.SeekOrigin.Start)
    expect(walker.c).toBe("\uDE00")
    walker.seek(0, util.SeekOrigin.End)
    expect(walker.c).toBe("")
    walker.seek(-10)
    expect(walker.c).toBe("\uDE00")
    walker.seek(3)
    expect(walker.c).toBe("")
    expect(walker.eof).toBe(true)
  })

  test('take()', () => {
    const walker = new StringWalker("input   x")
    expect(walker.take(0)).toBe("")
    expect(walker.take(5)).toBe("input")
    expect(walker.c).toBe(" ")
    expect(walker.take(c => c === "x")).toBe("")
    expect(walker.take(c => c === " ")).toBe("   ")
    expect(walker.c).toBe("x")
    walker.take(1)
    expect(walker.eof).toBe(true)
  })

  test('skip()', () => {
    const walker = new StringWalker("input   x")
    expect(walker.c).toBe("i")
    walker.skip(0)
    expect(walker.c).toBe("i")
    walker.skip(5)
    expect(walker.c).toBe(" ")
    walker.skip(c => c === "x")
    expect(walker.c).toBe(" ")
    walker.skip(c => c === " ")
    expect(walker.c).toBe("x")
    walker.skip(5)
    expect(walker.eof).toBe(true)
  })

  test('skip()', () => {
    const walker = new StringWalker("  input   x")
    walker.skip(c => c === " ")
    walker.markStart()
    walker.skip(c => c !== " ")
    walker.markEnd()
    expect(walker.getMarked()).toBe("input")
  })

})
